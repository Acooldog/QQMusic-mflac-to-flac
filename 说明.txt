用户要求生成一个目录示例，以及每个目录所对应的代码。根据我对项目的理解，这个项目主要涉及以下几个方面：

1. 项目根目录的结构
2. QQ音乐下载目录
3. 输出目录
4. 代码文件的对应关系

我应该展示：
1. 项目目录结构
2. QQMusic下载目录示例
3. Output输出目录示例
4. 关键代码文件的对应关系

让我整理一个清晰的示例。
我来为你生成完整的目录结构和对应的代码示例。

## 一、项目目录结构

```
qqmusic_decrypt/
├── Cargo.toml              # Rust项目配置
├── CHANGELOG.md            # 版本变更日志
├── README.MD               # 项目说明文档
├── hook_qq_music.js        # JavaScript Hook脚本（注入到QQ音乐）
├── src/
│   └── main.rs            # Rust主程序
└── output/                 # 程序运行后生成（解密后的音频文件）
    ├── song1.flac
    ├── song2.ogg
    └── ...
```

## 二、各目录对应的代码

### 1. 项目根目录 `qqmusic_decrypt/`

**`Cargo.toml` - 项目依赖配置**
```toml
[package]
name = "qqmusic_des"
version = "0.1.0"
edition = "2024"

[dependencies]
frida = { version = "0.16" ,features = ["auto-download"]}  # 动态插桩框架
anyhow = "1"                                               # 错误处理
md5 = "0.8"                                                # 文件名哈希
serde_json = "1"                                           # 与JS通信
```

**`README.MD` - 使用说明**
```markdown
# qq音乐破解 QQ MUSIC Description
* 自动搜索qq音乐下载目录下的文件
* mflac 自动转换为 flac 到当前目录的output
* mgg 自动转换为 ogg 到当前目录的output
```

### 2. `src/` 目录

**`src/main.rs` - 主程序（完整代码）**

```rust
use anyhow::{Context, Result};
use frida::{Frida, Message};
use serde_json::json;
use std::env::{current_dir, home_dir};
use std::sync::LazyLock;

// Frida全局单例
static FRIDA: LazyLock<Frida> = LazyLock::new(|| unsafe { Frida::obtain() });

fn main() -> Result<()> {
    // 获取设备管理器和本地设备
    let device_manager = frida::DeviceManager::obtain(&FRIDA);
    let device = device_manager.get_local_device()?;
    println!("[*] Frida version: {}", Frida::version());
    println!("[*] Device name: {}", device.get_name());
    
    // 查找QQ音乐进程
    let qq_music_process = device
        .enumerate_processes()
        .into_iter()
        .find(|x| x.get_name().to_ascii_lowercase().contains("qqmusic"))
        .context("请先启动QQ音乐")?;

    // 附加到QQ音乐进程并加载Hook脚本
    let session = device.attach(qq_music_process.get_pid())?;
    let mut script_option = frida::ScriptOption::default();
    let js = include_str!(".././hook_qq_music.js");
    let mut script = session.create_script(js, &mut script_option)?;
    script.handle_message(Handler)?;
    script.load()?;

    // 构造QQ音乐下载目录路径
    let qq_music_dir = home_dir()
        .context("无法获取home主目录")?
        .join("Music")
        .join("VipSongsDownload");

    println!("[*] QQ音乐目录: {}", qq_music_dir.display());

    // 创建输出目录
    let output = current_dir()?.join("output");
    if !output.exists() {
        std::fs::create_dir(&output)?;
    }

    // 遍历QQ音乐下载目录中的文件
    for file in qq_music_dir.read_dir()?.flatten() {
        let path = file.path();
        if path.is_file() {
            if let Some(extension) = path.extension().and_then(|s| s.to_str()) {
                // 映射文件扩展名：mflac→flac, mgg→ogg
                let new_ext = match extension {
                    "mflac" => "flac",
                    "mgg" => "ogg",
                    _ => continue,
                };
                
                // 构造输出文件路径
                let mut new_file_name = path.clone();
                new_file_name.set_extension(new_ext);
                let new_file_name = new_file_name.file_name().unwrap().to_str().unwrap();
                let new_file_path = output.join(new_file_name);
                
                // 跳过已存在的文件
                if new_file_path.exists() {
                    println!(
                        "[*] 文件已存在: {} 跳过处理",
                        new_file_path.display()
                    );
                    continue;
                }
                
                // 生成临时文件名（MD5哈希）
                let md5_file_name = format!("{:x}", md5::compute(new_file_name));
                let new_md5_path = output.join(md5_file_name);               
                
                // 调用JavaScript RPC进行解密
                script.exports.call(
                    "decrypt",
                    Some(json!([
                        path.display().to_string(),
                        new_md5_path.display().to_string()
                    ])),
                )?;
                
                // 重命名临时文件为最终文件名
                std::fs::rename(&new_md5_path, &new_file_path).context(format!(
                    "无法重命名文件: {} -> {}",
                    new_md5_path.display(),
                    new_file_path.display()
                ))?;
                
                println!(
                    "[*] 处理文件: {} 完成",
                    new_file_path.display()
                );
            }
        }
    }

    Ok(())
}

// 消息处理器
struct Handler;
impl frida::ScriptHandler for Handler {
    fn on_message(&mut self, message: &Message, _data: Option<Vec<u8>>) {
        println!("- {:?}", message);
    }
}
```

### 3. 根目录 `hook_qq_music.js`

**`hook_qq_music.js` - Hook脚本（完整代码）**

```javascript
// 目标DLL
const TARGET_DLL = "QQMusicCommon.dll";

// 查找EncAndDesMediaFile类的6个关键函数的导出地址
var EncAndDesMediaFileConstructorAddr = Module.findExportByName(
  TARGET_DLL,
  "??0EncAndDesMediaFile@@QAE@XZ"  // 构造函数
);

var EncAndDesMediaFileDestructorAddr = Module.findExportByName(
  TARGET_DLL,
  "??1EncAndDesMediaFile@@QAE@XZ"  // 析构函数
);

var EncAndDesMediaFileOpenAddr = Module.findExportByName(
  TARGET_DLL,
  "?Open@EncAndDesMediaFile@@QAE_NPB_W_N1@Z"  // 打开文件
);

var EncAndDesMediaFileGetSizeAddr = Module.findExportByName(
  TARGET_DLL,
  "?GetSize@EncAndDesMediaFile@@QAEKXZ"  // 获取大小
);

var EncAndDesMediaFileReadAddr = Module.findExportByName(
  TARGET_DLL,
  "?Read@EncAndDesMediaFile@@QAEKPAEK_J@Z"  // 读取数据
);

// 将函数地址包装为可调用的JavaScript函数
var EncAndDesMediaFileConstructor = new NativeFunction(
  EncAndDesMediaFileConstructorAddr,
  "pointer",
  ["pointer"],
  "thiscall"
);

var EncAndDesMediaFileDestructor = new NativeFunction(
  EncAndDesMediaFileDestructorAddr,
  "void",
  ["pointer"],
  "thiscall"
);

var EncAndDesMediaFileOpen = new NativeFunction(
  EncAndDesMediaFileOpenAddr,
  "bool",
  ["pointer", "pointer", "bool", "bool"],
  "thiscall"
);

var EncAndDesMediaFileGetSize = new NativeFunction(
  EncAndDesMediaFileGetSizeAddr,
  "uint32",
  ["pointer"],
  "thiscall"
);

var EncAndDesMediaFileRead = new NativeFunction(
  EncAndDesMediaFileReadAddr,
  "uint",
  ["pointer", "pointer", "uint32", "uint64"],
  "thiscall"
);

// 导出RPC函数供Rust调用
rpc.exports = {
  decrypt: function (srcFileName, tmpFileName) {    
    // 1. 分配对象内存（0x28字节 = 对象大小）
    var EncAndDesMediaFileObject = Memory.alloc(0x28);
    
    // 2. 调用构造函数初始化
    EncAndDesMediaFileConstructor(EncAndDesMediaFileObject);

    // 3. 转换路径为UTF-16编码
    var fileNameUtf16 = Memory.allocUtf16String(srcFileName);
    
    // 4. 打开加密文件
    EncAndDesMediaFileOpen(EncAndDesMediaFileObject, fileNameUtf16, 1, 0);

    // 5. 获取文件大小
    var fileSize = EncAndDesMediaFileGetSize(EncAndDesMediaFileObject);

    // 6. 分配读取缓冲区
    var buffer = Memory.alloc(fileSize);
    
    // 7. 读取解密后的数据
    EncAndDesMediaFileRead(EncAndDesMediaFileObject, buffer, fileSize, 0);

    // 8. 转换为字节数组
    var data = buffer.readByteArray(fileSize);
    
    // 9. 释放对象资源
    EncAndDesMediaFileDestructor(EncAndDesMediaFileObject);

    // 10. 写入临时文件
    var tmpFile = new File(tmpFileName, "wb");
    tmpFile.write(data);
    
    return true;
  },
};
```

### 4. QQ音乐下载目录（外部目录）

**`~/Music/VipSongsDownload/` - QQ音乐默认下载目录**

```
C:\Users\YourName\Music\VipSongsDownload\
├── 陈奕迅-十年.mflac        # 加密的FLAC文件（VIP歌曲）
├── 周杰伦-稻香.mflac        # 加密的FLAC文件
├── 邓紫棋-泡沫.mgg          # 加密的OGG文件（普通品质）
├── 林俊杰-江南.mflac        # 加密的FLAC文件
└── 梁静茹-勇气.mgg          # 加密的OGG文件
```

**目录对应的代码逻辑**：
```rust
// main.rs 第27-30行
let qq_music_dir = home_dir()
    .context("无法获取home主目录")?
    .join("Music")
    .join("VipSongsDownload");
```

### 5. 输出目录（程序运行后生成）

**`./output/` - 解密后的音频文件**

```
o:\A_javascript\qqmusic_decrypt\output\
├── 陈奕迅-十年.flac         # 解密后的FLAC文件
├── 周杰伦-稻香.flac         # 解密后的FLAC文件
├── 邓紫棋-泡沫.ogg          # 解密后的OGG文件
├── 林俊杰-江南.flac         # 解密后的FLAC文件
└── 梁静茹-勇气.ogg          # 解密后的OGG文件
```

**目录对应的代码逻辑**：
```rust
// main.rs 第34-37行（创建输出目录）
let output = current_dir()?.join("output");
if !output.exists() {
    std::fs::create_dir(&output)?;
}

// main.rs 第48-51行（构造输出文件路径）
let mut new_file_name = path.clone();
new_file_name.set_extension(new_ext);  // mflac → flac, mgg → ogg
let new_file_name = new_file_name.file_name().unwrap().to_str().unwrap();
let new_file_path = output.join(new_file_name);
```

### 6. 临时文件（处理过程中生成）

**`./output/{md5_hash}` - 临时文件（处理完成后被重命名）**

```
o:\A_javascript\qqmusic_decrypt\output\
├── 5d41402abc4b2a76b9719d911017c592  # "陈奕迅-十年.flac"的MD5哈希
├── 098f6bcd4621d373cade4e832627b4f6  # "周杰伦-稻香.flac"的MD5哈希
└── ...（这些文件会被重命名为最终文件名）
```

**对应的代码逻辑**：
```rust
// main.rs 第59-60行（生成MD5临时文件名）
let md5_file_name = format!("{:x}", md5::compute(new_file_name));
let new_md5_path = output.join(md5_file_name);
```

```javascript
// hook_qq_music.js 第79-80行（写入临时文件）
var tmpFile = new File(tmpFileName, "wb");
tmpFile.write(data);
```

## 三、目录与代码映射表

| 目录/文件 | 对应代码行号 | 作用 |
|----------|-------------|------|
| `qqmusic_decrypt/src/main.rs` | 整个文件 | Rust主程序入口 |
| `qqmusic_decrypt/hook_qq_music.js` | 整个文件 | JavaScript Hook脚本 |
| `~/Music/VipSongsDownload/` | main.rs:27-30 | 输入目录（加密文件） |
| `./output/` | main.rs:34-37 | 输出目录（解密文件） |
| `./output/{md5_hash}` | main.rs:59-60 + js:79-80 | 临时文件（处理中） |
| `./output/{song}.{ext}` | main.rs:69-73 | 最终文件（重命名后） |

## 四、数据流向示意图

```
[~/Music/VipSongsDownload/song.mflac]
         ↓ main.rs:62-68 (RPC调用)
[hook_qq_music.js decrypt函数]
         ↓ js:73-76 (读取解密数据)
[./output/{md5_hash} 临时文件]
         ↓ main.rs:69-73 (重命名)
[./output/song.flac 最终文件]
```

这个目录结构清晰地展示了项目的组织方式、输入输出路径以及代码与文件系统的对应关系。